import logging
import sys
from datetime import datetime, timedelta
from time import sleep

from bg_deploy.AWS_Models.asg import Asg
from bg_deploy.helper_functions import _determine_asg, _determine_elb_health, _determine_new_instances_in_elb, _input_loop, _elb_health_check

ASG_BLUE_FORMAT = '{service}-blue'
ASG_GREEN_FORMAT = '{service}-green'

class FSM(object):
    def __init__(self,
                 service_name,
                 canary=False,
                 canary_elb=False,
                 launch_config=None,
                 canary_timeout=None,
                 scaleup_timeout=120,
                 profile=None,
                 stagger=False,
                 step=None):
        """
        Finite state machine for deploying to B\G ASGs
        :param service_name: String, representing the service being deployed
        :param canary: Bool, whether the canary state is required
        """
        # Setup attached logging module
        self.logger = logging.getLogger('FSM_application')
        out_hdlr  = logging.StreamHandler(sys.stdout)
        out_hdlr.setLevel(logging.DEBUG)
        self.logger.addHandler(out_hdlr)
        self.logger.setLevel(logging.DEBUG)

        self.cur_state = 'Init'
        self.prev_state = None
        self.service_name = service_name
        self.canary = canary
        self.canary_elb = canary_elb
        self.canary_timeout = canary_timeout
        self.scaleup_timeout = scaleup_timeout
        self.abort_message = None
        self.target_asg = None
        self.target_asg_org_configuration = None
        self.original_asg = None
        self.original_asg_org_configuration = None
        self.launch_config = launch_config
        self.profile = profile
        self.stagger = stagger
        self.step = step

    def init_handler(self):
        self.logger.info("=" * 37)
        # print("Init: Entering Init state")
        self.logger.info('Init: Entering Init State')

        # Assume ASG names are well known
        asg1 = ASG_BLUE_FORMAT.format(service=self.service_name)
        asg2 = ASG_GREEN_FORMAT.format(service=self.service_name)

        # Instantiate each ASG
        asg1 = Asg(asg1, self.profile)
        asg2 = Asg(asg2, self.profile)

        # Determine which ASG is target, function will return false if cannot determine
        results = _determine_asg(asg1, asg2)

        if not results:
            self.logger.info("Init: Could not determine target ASG, Aborting!!")
            self.cur_state = 'Abort'
            self.prev_state = 'Init'
            self.abort_message = "Failed during INIT state. Could not determine which ASG is target"
            return

        self.logger.info("Init: Target: {}, Original: {}".format(results['Target'].name, results['Original'].name))
        self.target_asg = results['Target']
        self.original_asg = results['Original']

        # Disable Scale Down
        self.logger.info("Init: Disabled scale down on target ASG: ({})".format(self.target_asg.name))
        self.target_asg.disable_scale_down()

        # If target ASG is attached to ELB, remove
        if len(self.target_asg.attached_loadbalancers) > 0:
            self.logger.info("Init: Found load balancers {}. Removing".format(self.target_asg.attached_loadbalancers))
            self.target_asg.detach_loadbalancers(self.target_asg.attached_loadbalancers)

        # Store original configuration state of original
        self.original_asg_org_configuration = self.original_asg._get_desc()

        # If launch config is specified, apply to target ASG
        if self.launch_config:
            self.logger.info("Init: Applying Launch Configuration: {} to target ASG".format(self.target_asg.launch_configuration))
            self.target_asg.launch_configuration = self.launch_config

        # Determine if next state should be canary, or ScaleUp
        if self.canary:
            self.logger.info("Init: Init Finished, state change to Canary")
            self.cur_state = 'Canary'
            self.prev_state = 'Init'
        else:
            self.logger.info("Init: Init finished, state change to ScaleUp")
            self.cur_state = 'ScaleUp'
            self.prev_state = 'Init'

        return

    def canary_handler(self):
        self.logger.info("=" * 37)
        self.logger.info("Canary: Entering Canary State")

        # If canary ELB specified, add only canary ELB, else add original ELB's
        if self.canary_elb:
            self.logger.info("Canary: Canary ELB was specified, attaching {}-canary ELB".format(self.service_name))
            self.target_asg.attached_loadbalancers("{}-canary".format(self.service_name))
        else:
            self.logger.info("Canary: Canary ELB not specified, adding originally configured ELBs: "
                  "{}".format(self.original_asg_org_configuration['LoadBalancerNames']))
            self.target_asg.attach_loadbalancers(self.original_asg_org_configuration['LoadBalancerNames'])

        # Set desired to one
        self.logger.info("Canary: Set target ASG: ({}) Desired_Capacity to 1, Min_Size to 0, "
              "and Max_Size to 1".format(self.target_asg.name))
        self.target_asg.max_size = 1
        self.target_asg.min_size = 0
        self.target_asg.desired_capacity = 1

        # Wait for asg instance count to be 1
        while self.target_asg.instance_count < 1:
            self.logger.info("Canary: Waiting for target ASG: ({}) instance count to increase".format(self.target_asg.name))
            sleep(15)

        # Wait for ELB to reflect new instances in ASG
        _determine_new_instances_in_elb(self.target_asg, self.cur_state)

        # Wait until healthy
        now = datetime.now()
        while not _determine_elb_health(self.target_asg):
            if datetime.now() <= now + timedelta(0, self.canary_timeout):
                self.logger.info("Canary: Waiting for ELB health checks")
                sleep(30)
            else:
                self.prev_state = 'Canary'
                self.cur_state = 'Abort'
                self.abort_message = 'Canary: ELB health check threshold expired'
                return

        # Canary is now live, wait for user interactions, state transition to abort if necessary
        print("Canary: Canary is now live, please proceed with manual testing.")
        if _input_loop('Proceed: Y/N '):
            # State transition
            self.cur_state = 'ScaleUp'
            self.prev_state = 'Canary'
        else:
            # State transition
            self.prev_state = 'Canary'
            self.cur_state = 'Abort'
            self.abort_message = "During Canary State, user chose not to proceed"

    def scaleup_handler(self):
        self.logger.info("=" * 37)
        self.logger.info("ScaleUp: Entering ScaleUp State")

        # if canary_elb set, remove canary elb, and add original, else check that target attached ELB matches Original
        if self.canary_elb:
            self.logger.info("ScaleUp: Canary ELB was set, removing and adding original EBLs: "
                  "{}".format(self.original_asg_org_configuration['LoadBalancerNames']))
            self.target_asg.detach_loadbalancers(self.target_asg.attached_loadbalancers)
            self.target_asg.attach_loadbalancers(self.original_asg_org_configuration['LoadBalancerNames'])
        else:
            if sorted(self.target_asg.attached_loadbalancers) != \
                    sorted(self.original_asg_org_configuration['LoadBalancerNames']):
                self.logger.info("ScaleUp: Adding original "
                                 "ELBs: {}".format(self.original_asg_org_configuration['LoadBalancerNames']))
                self.target_asg.attach_loadbalancers(self.original_asg_org_configuration['LoadBalancerNames'])


        # Configure target ASG with Original ASG settings
        self.logger.info("ScaleUp: Configuring target ASG: ({}) with original ASG: ({}) configuration "
                         "Max_Size: {}, Min_Size: {}, Desired: {}".format(self.target_asg.name,
                                                                          self.original_asg.name,
                                                                          self.original_asg.max_size,
                                                                          self.original_asg.min_size,
                                                                          self.original_asg.desired_capacity))

        self.target_asg.max_size = self.original_asg.max_size
        self.target_asg.min_size = self.original_asg.min_size
        self.target_asg.desired_capacity = self.original_asg.desired_capacity

        # Wait for all instances to be present, check against static original configuration state in case of scaling event during deploy
        while self.target_asg.instance_count < self.original_asg_org_configuration['DesiredCapacity']:
            self.logger.info("ScaleUp: Waiting for target ASG: ({}) instance count to increase".format(self.target_asg.name))
            sleep(15)

        # Wait on ELB health check
        _determine_new_instances_in_elb(self.target_asg, self.cur_state)

        # Wait for ELB health checks to pass
        # now = datetime.now()
        # while not _determine_elb_health(self.target_asg):
        #     if datetime.now() <= now + timedelta(0, self.scaleup_timeout):
        #         self.logger.info("ScaleUp: Waiting for elb health checks")
        #         sleep(30)
        #     else:
        #         self.prev_state = 'ScaleUp'
        #         self.cur_state = 'Abort'
        #         self.abort_message = 'ScaleUp: ELB health check threshold expired'
        #         return

        if _elb_health_check(self.target_asg, self.scaleup_timeout, self.cur_state):
            self.prev_state = 'ScaleUp'
            self.cur_state = 'Finish'
        else:
            self.prev_state = 'ScaleUp'
            self.cur_state = 'Abort'
            self.abort_message = 'ScaleUp: ELB health check threshold expired'

        # self.prev_state = 'ScaleUp'
        # self.cur_state = 'Finish'

        return

    def finish_handler(self):
        self.logger.info("=" * 37)
        self.logger.info("Finish: Entering Finish State")

        # Remove ELB's from original ASG
        self.logger.info("Finish: Removing ELBs from original ASG")
        self.original_asg.detach_loadbalancers(self.original_asg.attached_loadbalancers)

        # Enable scaleup
        self.target_asg.enable_scale_down()

        # Wait for user input
        print("Finish: ELB has been removed from Original ASG: ({}), Waiting for user input to continue. "
              "Next step is to terminate the instances!!".format(self.original_asg.name))

        if _input_loop('Proceed Y/N? '):
            self.logger.info("Finish: Setting original ASG: ({}) desired_capacity to 0".format(self.original_asg.name))
            self.original_asg.desired_capacity = 0
            while self.original_asg.instance_count != 0:
                self.logger.info("Finish: Waiting for original ASG: ({}) to report instances are 0".format(self.original_asg.name))
                sleep(30)
        else:
            self.prev_state = 'Finish'
            self.cur_state = 'Abort'
            self.abort_message = 'Finish: User aborted finish state, ' \
                                 'instances have not been terminated from original ASG'

        self.logger.info("Finish: Finish state has completed. No further state transition is necessary")

    def abort_handler(self):

        self.logger.info("Abort: Aborted from previous state {}".format(self.prev_state))
        self.logger.info("Abort: Aborted for the following reason:\n    {}".format(self.abort_message))
        input("Abort: Please investigate issues and press any key when ready...")

    def run(self):
        if self.cur_state == 'Init':
            self.init_handler()
        if self.cur_state == 'Canary':
            self.canary_handler()
        if self.cur_state == 'ScaleUp':
            self.scaleup_handler()
        if self.cur_state == 'Finish':
            self.finish_handler()
        if self.cur_state == 'Abort':
            self.abort_handler()

