from datetime import datetime, timedelta
from time import sleep

from bg_deploy.AWS_Models.elb import Elb


def _determine_asg(ASG1, ASG2):
    """
    Determines the target ASG based on instance count. Will return False if target and original cannot be determined
    :param ASG1: ASG Object
    :param ASG2: ASG Objects
    :return:
    """

    target, original = sorted([ASG1, ASG2], key=lambda asg: asg.instance_count)

    if target.instance_count == 0 and original.instance_count > 0:
        return {'Target': target, 'Original': original}

    return False


def _determine_elb_health(ASG):
    """
    Creates a list comprehension of Healthy codes (True/False)
    :param ASG: An ASG Object
    :return:
    """
    results = ASG.attached_loadbalancers_health

    return all(code['Healthy'] for code in results)

def _elb_health_check(ASG, threshold, state):
    now = datetime.now()
    while not _determine_elb_health(ASG):
        if datetime.now() <= now + timedelta(0, threshold):
            print("{}: Waiting for ELB health checks to pass".format(state))
            sleep(.5)
        else:
            return False
    return True


def _determine_new_instances_in_elb(ASG):
    """
    Obtains list of instances within ASG. For ever load balancer associated with the ASG instantiate an ELB object.
    While loop condition is True, obtain a list of instances associated with the ELB, determine the differences
    between ASG list and ELB list, and if difference list is the same as ASG list, set loop condition to False and exit
    loop. This allows every attached load balancer to be checked in a serial fashion.
    :param ASG: An ASB Object
    :return:
    """

    ASG_Instances = [record['InstanceId'] for record in ASG.instances]

    for LB in ASG.attached_loadbalancers:
        elb = Elb(LB, ASG.profile)
        Loop = True
        while Loop:

            elb_instances = [InstanceId['InstanceId'] for InstanceId in elb.instances]
            difference_list = [i for i in elb_instances if i in ASG_Instances]
            sleep(30)

            if sorted(difference_list) == sorted(ASG_Instances):
                Loop = False


def stagger_deploy(ASG, interval, desired, step):
    si = step
    print("ASG Desired count (first) {}".format(si))
    ASG.desired_capacity = si

    while ASG.instance_count < si:
        sleep(15)

    _determine_new_instances_in_elb(ASG)



    sleep(interval)
    desired -= step

    while desired >= step:
        si += step
        print("ASG Desired Count in {}".format(si))
        ASG.desired_capacity = si
        sleep(interval)
        desired -= step

    if desired == 0:
        print("Done")
    elif desired > 0:
        print("ASG Desired Count (final): {}".format(si + desired))
        ASG.desired_capacity = (si + desired)


def _input_loop(msg):
    usr_input = input(msg)

    if usr_input.upper() in ['YES', 'Y']:
        return True
    elif usr_input.upper() in ['NO', 'N']:
        return False
    else:
        _input_loop(msg)



